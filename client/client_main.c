#undef UNICODE

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include "../com/chat_rpc.h" // header file generated by the MIDL compiler

// TODO listen to server
#define RECEIVE_MODE "1"
#define SEND_MODE "2"

void Usage(char *pszProgramName) {
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -n network_address\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -u user_name\n");
    fprintf(stderr, " -m mode: 1 - reeive, 2 - send\n");
    exit(1);
}

void main(int argc, char **argv) {
    RPC_STATUS status;
    unsigned char *pszUuid = NULL;
    unsigned char *pszProtocolSequence = "ncacn_np";
    unsigned char *pszNetworkAddress = NULL;
    unsigned char *pszEndpoint = "\\pipe\\hello";
    unsigned char *pszOptions = NULL;
    unsigned char *pszStringBinding = NULL;

    unsigned char *userName = "noname";
    unsigned char *mode = "1";

    /* Allow the user to override settings with command line switches */
    for (int i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i] + 1))) {
            case 'p': // protocol sequence
                pszProtocolSequence = argv[++i];
                break;
            case 'n': // network address
                pszNetworkAddress = argv[++i];
                break;
            case 'e': // endpoint
                pszEndpoint = argv[++i];
                break;
            case 'o': // options
                pszOptions = argv[++i];
                break;
            case 'u': // user name
                userName = argv[++i];
                break;
            case 'm': // mode
                mode = argv[++i];
                break;
            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        }
        else
            Usage(argv[0]);
    }

    /* Use a convenience function to concatenate the elements of */
    /* the string binding into the proper sequence               */
    status = RpcStringBindingCompose(
        pszUuid,
        pszProtocolSequence,
        pszNetworkAddress,
        pszEndpoint,
        pszOptions,
        &pszStringBinding);

    printf("[INFO] RpcStringBindingCompose returned 0x%x\n", status);
    printf("[INFO] pszStringBinding = %s\n", pszStringBinding);
    if (status)
        exit(status);

    /* Set the binding handle that will */
    /* be used to bind to the server  */
    status = RpcBindingFromStringBinding(pszStringBinding, &chat_IfHandle);

    printf("[INFO] RpcBindingFromStringBinding returned 0x%x\n", status);
    if (status)
        exit(status);

    /* Remote calls go here */
    int clientId = Login_(userName);
    printf("\nSession started!\n");
    printf("Your client ID is %d\n\n", clientId);

    /* Main app loop */
    unsigned char cmd;
    int messageId;
    int loggedOut = 0;

    while (1) {
      printf("Enter command:\nu - user list\ns - send message\nr - receive message\nc - check message status\nq - quit\n");
      scanf("%c", &cmd);
      getchar(); // read extra newline char

      switch (cmd) {
      case 'u':
          Users_();
          break;
      case 's':
          // if (strcmp(mode, RECEIVE_MODE)) {
          //   printf("You need to use a different app mode. Restart your application with '-m 2'.");
          // } else if (strcmp(mode, SEND_MODE)) {
          //   printf("Not implemented. Live with it.");
          // }
          messageId = Send_(clientId);
          printf("Message sent, ID: %d\n\n", messageId);
          break;
      case 'r':
          Receive_(clientId);
          break;
      case 'c':
          printf("Enter message ID: ");
          scanf("%d", &messageId); getchar();
          printf("Message status: %d\n\n", Status_(clientId, messageId));
          break;
      case 'q':
          Logout_(clientId);
          loggedOut = 1;
          break;
      default:
          printf("Invalid command\n\n");
      }

      if (loggedOut) break;
    }

    printf("\nSession ended\n\n");

    /*  The calls to the remote procedures are complete. */
    /*  Free the string and the binding handle           */
    status = RpcStringFree(&pszStringBinding);
    printf("[INFO] RpcStringFree returned 0x%x\n", status);
    if (status)
        exit(status);

    status = RpcBindingFree(&chat_IfHandle);
    printf("[INFO] RpcBindingFree returned 0x%x\n", status);
    if (status)
        exit(status);

    exit(0);
}

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len) {
	return(malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr) {
	free(ptr);
}

int Login_(unsigned char *userName) {
    unsigned long ulCode;
    int clientId = 0;

    RpcTryExcept {
        printf("\n[DEBUG] Calling remote procedure Login(userName='%s')\n", userName);
        clientId = Login(userName);
    }

    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("[ERROR] Runtime reported exception 0x%lx \n\n", ulCode);
    }

    RpcEndExcept

    return clientId;
}

int Logout_(int clientId) {
    unsigned long ulCode;

    RpcTryExcept {
        printf("\n[DEBUG] Calling remote procedure Logout(clientId=%d)\n", clientId);
        Logout(clientId);
    }

    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("[ERROR] Runtime reported exception 0x%lx\n\n", ulCode);
    }

    RpcEndExcept

    return 0;
}

int Users_() {
    unsigned long ulCode;
    unsigned char usersList[ USERS_COUNT ][ STR_LEN ];

    RpcTryExcept {
        printf("\n[DEBUG] Calling remote procedure GetUsersList()\n");
        GetUsersList(usersList);
        for (int i = 0; i < USERS_COUNT; i++) {
            if (usersList[i] == NULL) {
                break;
      	    }
            printf("[%2d]: %s\n", i + 1, usersList[i]);
        }
    }

    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("[ERROR] Runtime reported exception 0x%lx\n\n", ulCode);
    }

    RpcEndExcept

    return 0;
}

int Send_(int clientId) {
    unsigned long ulCode;
    char receiver[STR_LEN] = "";
    char text[STR_LEN] = "";
    int messageId;

    printf("To: ");
    fgets(receiver, STR_LEN, stdin);
    printf("Message text (limit - %d symbols):\n", STR_LEN);
    fgets(text, STR_LEN, stdin);

    RpcTryExcept {
        printf("\n[DEBUG] Calling remote procedure SendMyMessage(clientId=%d, receiver=%s)\n", clientId, receiver);
        messageId = SendMyMessage(clientId, text, receiver);
    }

    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("[ERROR] Runtime reported exception 0x%lx\n\n", ulCode);
    }

    RpcEndExcept

    return messageId;
}

int Status_(int clientId, int messageId) {
    unsigned long ulCode;
    int status = -1;

    RpcTryExcept {
        printf("\n[DEBUG] Calling remote procedure GetMessageStatus(clientId=%d, messageId=%d)\n", clientId, messageId);
        status = GetMessageStatus(clientId, messageId);
    }

    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("[ERROR] Runtime reported exception 0x%lx\n\n", ulCode);
    }

    RpcEndExcept

    return status;
}

int Receive_(int clientId) {
    unsigned long ulCode;
    unsigned char sender[STR_LEN];
    unsigned char message[STR_LEN];

    RpcTryExcept {
        printf("\n[DEBUG] Calling remote procedure ReceiveMyMessage(clientId=%d)\n", clientId);
        ReceiveMyMessage(clientId, sender, message);
        printf("From: %s\n%s\n\n", sender, message);
    }

    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("[ERROR] Runtime reported exception 0x%lx\n\n", ulCode);
    }

    RpcEndExcept

    return 0;
}
